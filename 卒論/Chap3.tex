% !TEX root = Sotsuron_main_v3.tex
%%Chap2
本章では，本研究で取り扱うCTS問題 (Continuous similarity search for Text Streams) 問題\cite{kubo}の定義を述べる．

\section{CTS問題}

CTS問題ではユーザ$A$を$A$が投稿したテキストの集合で特徴づける．テキストは単語の
集合である．例えば，Twitterのユーザを投稿したtweetで特徴づけるということになる．
各ユーザ$A$が単位時間毎に新しいテキストを1つ投稿するストリーム環境を想定する．

各データストリーム$A$には幅$W$のスライディングウィンドウが設定され，スライディングウィンドウは$A$に到着した直近$W$個の要素が含まれる．
つまり，CTS問題では時刻$T$のユーザ$A$が保有するテキスト集合$A_T$は，$A_T=\{a_{T-W+1},a_{T-W+2},...,a_T\}$となる．時刻$T$か
ら$T+1$に更新された時，図\ref{sw}のようにスライディングウィンドウに$a_{T+1}$が到着し，$a_{T-W+1}$が離脱する．
\begin{figure}[htb]
  \begin{center}
    \includegraphics[clip,width=\linewidth]{img/sw.eps}
    \caption{スライディングウィンドウモデル}
    \label{sw}
  \end{center}
\end{figure}

CTS問題は，多数のユーザのテキストストリームを保持したデータベース$D$とクエリユーザ$V$のテキストストリームが与えられて，
毎時刻クエリ$V$とのユーザ間類似度$\mbox{sim}(V_T,U_T)$が閾値$\epsilon_u$以上であるすべてのユーザ$U$を$D$から検索する
継続的なレンジ探索である．したがって，スライディングウィンドウが変化する度に類似度判定結果を更新することが要求される．

ここでテキスト集合$V_T，U_T$間の類似度 $\mbox{sim}(V_T,U_T)$は以下のように定義される．
\begin{enumerate}
\item $V_T$と$U_T$の類似テキストペア間に辺を張り2部グラフ$G(V_T,U_T)$を構成する．
ここで2つのテキスト$o\in V_T，o'\in U_T$が類似テキストペアとなる条件は，$o，o'$を単語集合と見なした時に
そのJaccard類似度
\begin{align}
\label{match}
\tau (o,o')=\frac{|o\cap o'|}{|o\cup o'|}
\end{align}
が$\tau (o,o')\geq \mbox{閾値}\epsilon_{doc}$という条件を満たすことである．直感的には，
共通単語を多く保有するテキストペアが類似テキストペアとなる．閾値$\epsilon_{doc}$はレンジ探索の際に指定されるパラメータとなる．
\item グラフ$G$の最大マッチング$M$のサイズ$|M|$を$\mbox{sim}(V_T,U_T)$とする．
\end{enumerate}

なお，上記で説明した問題は単位時間毎にテキストが投稿されるとしているが，本稿で扱うすべてのアルゴリズムは数単位時間ごとにテキストが投稿されるような，ユーザごとに一定でない時間間隔でテキストが投稿される場合にも対応可能である．

\section{近似レンジ探索}\label{kinjirange}
CTS問題は毎時刻スライディングウィンドウの内容が変化するため，クエリユーザ$V$とデータベース上のすべてのユーザ$U$との類似判定結果を毎時刻更新する必要がある．よって，最大マッチングを毎時刻求める必要がある．
しかし，データベース上の全ユーザに対して存在する二部グラフの最大マッチングを毎時刻求めることは計算量が大きくなってしまい困難である．そこで久保ら\cite{kubo}の研究でああるように本研究でも類似の定義をユーザ間の最大マッチングサイズが閾値$\epsilon_u$を超えるのではなく，ユーザ間の極大マッチングサイズが閾値$\epsilon_u$を超えるかとして扱う．
類似度に極大マッチングサイズを用いれば，一度マッチングが成立したテキストペア$(o，o')$はそのどちらかがスライディングウィンドウから離脱するまでマッチングを維持でき，マッチング判定の処理を省略することができるので，類似度の算出に必要な計算量が小さくなると考えられる．


\section{ユーザ間類似度}
以上より本問題は極大マッチングサイズをもとにユーザ間類似度を決定しているが，Zhangら\cite{zhang2021clustering}は異なる基準を用いてユーザ間類似度を定義している．
Zhangらの研究では，CTS問題と同様にJaccard類似度が閾値以上になるテキストペアに辺を張り二部グラフを構築しているが，極大マッチングサイズではなく，二部グラフの最大重みマッチングサイズをユーザ間類似度としている．つまりCTS問題ではJaccard類似度が閾値$\epsilon_{doc}$となるテキストペアをすべて同じ価値としてみなしているが，Zhangらの研究ではJaccard類似度を重みととらえ，テキストペア自体に価値を設定している．最大重みマッチングを用いることでより正確にユーザ間類似度を測ることができると考える．

しかし，\ref{kinjirange}節であるように最大マッチングを求めることは計算量的に困難である．これが最大重みマッチングの場合，さらに計算量が大きくなることが予想される．よって計算量の観点から本問題のユーザ間類似度に極大マッチングサイズを用いることは妥当だと考える．

---

多重集合

を表すアルファベットϕ に対して，その要素を0 個以上含むも
のが集合となる．通常，集合は同じ種類の要素を１つしか含ま
ない．集合を同じ種類の要素を複数持てるようにしたものを多
重集合という．つまり，{a, a, b, c, d, d, d} というような集合
である．

\section{多重集合}
一般にオブジェクトの集まりを集合と呼ぶ．例えば\{a, b, c\}はアルファベットを要素とする集合である．一般的には要素群を表すアルファベット$\phi$に対して，その要素を0個以上含むものが集合となる．通常，集合は同じ種類の要素を１つしか含まない．集合を同じ種類の要素を複数持てるようにしたものを多重集合という．つまり，\{a, a, b, c, d, d, d\}というような集合である．


\section{Jaccard係数}
集合間で類似検索を行うには集合がどれだけ似ているのかを表す集合間類似度が定義されている必要がある．そのうちの１つとして，Jaccard係数がある．
Jaccard係数は，ある集合$A$と別の集合$B$について，以下の式\ref{eq:sim}で定義される．
\begin{equation}
\label{eq:sim}
\mathrm{sim}(A,B)=  \frac {|A \cap {B} |} {|A \cup {B}| }
\end{equation}

つまり，Jaccard係数は２つの集合に含まれている要素のうち共通要素が占める割合を表している．
例えば，$A=\{a,c,d,f,g\}$,$B=\{a,b,c,e,g,h,i\}$というような２つの集合が存在するとすると，${A \cup {B} }=\{a,b,c,d,e,f,g,h,i\}$,$ {A \cap {B} }=\{a,c,g\}$となり，類似度$sim(A,B)=0.375$となる．

そして，Jaccard係数を多重集合に拡張したものを拡張Jaccard係数と言う(式 \ref{eq:exjaccard})．
\begin{equation}
\label{eq:exjaccard}
\mathrm{sim}(A,B)=  \frac {\sum{\mathrm{min}\{a_i,b_i\}}} {\sum{\mathrm{max}\{a_i,b_i\}} }\\
\end{equation}

ここで，$a_i$は集合$A$が要素$i∈\phi$を含む個数である．

\section{Min-hash}
Min-hashとは，集合に対する確率的なハッシュ関数であり，Jaccard係数を用いた集合間類似検索を高速化するための技術である \cite{Minhash}．クエリとデータベースかの集合間でJaccard係数を計算することはJaccard係数計算のオーバーヘッドが大きい．その問題を改善し，Jaccard係数を高速に近似計算する方法として，Min-hashという計算方法が考えられた．Min-hashは計算されたハッシュ値が一致する確率はJaccard係数と一致するという性質を持ち,類似集合ほどハッシュ値が一致しやすいという良い性質を持つ(式\ref{eq:jaccard})．

(1)のハッシュ値計算手法を例を用いて説明する．まず，図\ref{fig:2wariate}のように，アルファベット\{a,b,c,d\}に多重度が2である時の数値をランダムに割り当てる．
\begin{figure}[H]
  \centering
  \includegraphics[width=15cm]{multi22.png}
  \caption{多重集合のハッシュ値表}
  \label{fig:2wariate}
\end{figure}

多重集合$A =\{a,b,b,c,c,d,d\}$とする．多重集合$A$に対して，図\ref{fig:2wariate}の割り当て表を用いて数値を割り当てる．そして，その中の最小値がMin-Hashによるハッシュ値となる(図\ref{fig:255})．

\begin{figure}[H]
  \centering
  \includegraphics[width=15cm]{255.png}
  \caption{多重集合のハッシュ値計算}
  \label{fig:255}
\end{figure}

\section{スライディングウインドウモデル}
時刻$t$における集合を$A_t=\{e_{t-w+1},e_{t-w+2},\cdots,e_t\}$とする．$w$はスライディングウインドウの幅であり，
$A_t$は$w$個の要素で構成される．また，$A_t$の要素は到着時間順に並んでいる．図\ref{fig:window}では，$w=4$の時
に3つの時刻$t$,$t+1$,$t+2$に対する集合$A_t,A_{t+1},A_{t+2}$を図示している．そして，時刻によってスライディングウインドウは変化していく．
例えば，図\ref{fig:window}のようにデータストリーム$\{a,f,h,e,k,q,o,g\}$となっていて，ウインドウサイズ$w=4$とすると，時刻$t$では，
$A_{t}=\{e_{t-3},e_{t-2},e_{t-1},e_t\}$であり，時刻$t +1$では，$A_{t+1}=\{e_{t-2},e_{t-1},e_t,e_{t+1}\}$となる．

3. 問題点

3.1. Minlistの探索回数の増大

そもそもなぜMinlistの探索が必要なのか？

Minlistは，探索回数が多い．多重度のヒストグラムは要素Nが到着したときの到着時刻tをすべて記録している．しかしこの実装だとヒストグラムの要素数はスライディングウィンドウのサイズになる．このヒストグラムの到着時刻は．割り当て値であるハッシュ値の更新に使用する．要素γがウィンドウ内に存在する間、γ,et+1 間にラベルがl(et+1)となる要素がn個ある。よって、要素γ の存在尾期間中のet+1の割り当て値はπ(l(et+1)n) より大きくならなない。よってであれば，要素γ をMinlist から削除してよい．最後にMinlist の一番後ろにet+1 を挿入し，π(et+1) がMinlistの最小値を更新するかをチェックする．現在のハッシュ値よりπ(et+1) が小さいならば，ハッシュ値を更新する．

3.2. 割り当て表のメモリ割り当てのメモリが大きい

Min-hashを割り当てるためのハッシュ値の割り当て表のサイズは要素の種類数×多重度になる．しかし割り当て値の修正を行っているため，多重度が大きくなればなるほど割り当て値の変動する確率が下がる．そのため割り当て表はサイズが大きくなればなるほど意味を持たない割り当て値を多く持つことになりメモリ使用量に無駄が生じる．

3.3. ヒストグラムのメモリ割り当てのメモリが大きい

ヒストグラムのサイズは，要素の種類数の数だけ配列のサイズを確保する必要がある．ストリームデータが複数個になると，その数だけヒストグラムのメモリを確保する必要がある．また，スライディングウィンドウのサイズに対して要素の種類数が多いとヒストグラムの要素が0である比率が大きくなる．実質的に意味を持たない要素が多くなる．

4. 提案手法

3.1. Minlistの探索にSerch Limitを設ける



3.2. Active Indexを用いた割り当て表の作成

3.3. Count-Min Sketchを用いた多重度の近似ヒストグラムの作成